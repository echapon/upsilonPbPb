#include <algorithm>

void runLimit_Raa3S_Workspace(const char *poiname="raa3", const char *pdfname="joint", const char *wsname="wcombo");

#include "StandardHypoTestInvDemo.C"
#include "TwoSidedFrequentistUpperLimitWithBands.C"

double CI = 0.95;

void runLimit_Raa3S_Workspace(const char *poiname, const char *pdfname, const char *wsname)
{
   RooRealVar *theVar; RooDataSet *data; RooAbsPdf *pdf;
   // Open input file with workspace (generated by rf14_wspacewrite)
   TFile *f = new TFile("TRIAL.root") ;

   // Retrieve workspace from file
   RooWorkspace* ws = (RooWorkspace*) f->Get(wsname);
   RooStats::ModelConfig *sbHypo = (RooStats::ModelConfig*) ws->obj("SbHypo");
   RooStats::ModelConfig *bHypo = (RooStats::ModelConfig*) ws->obj("BHypo");
   cout << "observables: " << sbHypo->GetObservables()->getSize() << endl;
   theVar = ws->var(poiname);
   // if (!theVar) theVar = ws->function(poiname);
   pdf = ws->pdf(pdfname);
   data =(RooDataSet *) ws->data("data");

   // Print structure of composite p.d.f.
   pdf->Print("t") ;


   // get a first estimate of where to look

   // ProfileLikelihoodCalculator pl(*data,*pdf,*theVar);
   // cout << data << " " << pdf << " " << theVar << endl;
   // pl.SetConfidenceLevel(CI); 
   // int ci = 100*CI;
   // LikelihoodInterval* interval = pl.GetInterval();
   // LikelihoodIntervalPlot plot(interval);
   // TCanvas c4; c4.cd(); 
   // plot.SetRange(0.,0.,0.05,3.);
   // // plot.Draw();
   // TLatex latexCI;
   // latexCI.SetNDC();
   // latexCI.SetTextSize(0.035);
   // latexCI.DrawLatex(0.5,1.-0.05*2,Form("%s %d % C.I.",poiname,ci));
   // latexCI.DrawLatex(0.5,1.-0.05*3,Form("Upper limit: %f",interval->UpperLimit(*theVar)));
   // latexCI.DrawLatex(0.5,1.-0.05*4,Form("Lower limit: %f",interval->LowerLimit(*theVar)));
   // TString intrvlName = theVar->GetTitle();
   // // print out the iterval on the Parameter of Interest
   // cout <<endl<< CI <<"\% interval on " <<theVar->GetName()<<" is : ["<<
   //    interval->LowerLimit(*theVar) << ", "<<
   //    interval->UpperLimit(*theVar) << "] "<<endl;
   // pair<double, double> CnfdncIntrvl;
   // CnfdncIntrvl.first  = interval->LowerLimit(*theVar);
   // CnfdncIntrvl.second = interval->UpperLimit(*theVar);
   // c4.SaveAs("ULtest.pdf");

   // now let's move to the hypo test inverter
   /////////////////////////////////////////////////////////////
   // Now get the POI for convenience
   // you may want to adjust the range of your POI
   ////////////////////////////////////////////////////////////
   RooRealVar* firstPOI = (RooRealVar*) sbHypo->GetParametersOfInterest()->first();
   double muhat_data = theVar->getVal();
   double poimin = 0.;
   double poimax = 0.5;
   cout << "Will scan between " << poimin << " and " << poimax << endl;
   firstPOI->setMin(0.);
   firstPOI->setMax(0.5);

   // actually run the hypo test inverter

   // define calc type and test stat type
   // type = 0 Freq calculator 
   // type = 1 Hybrid calculator
   // type = 2 Asymptotic calculator  
   // type = 3 Asymptotic calculator using nominal Asimov data sets (not using fitted parameter values but nominal ones)
   //
   // testStatType = 0 LEP
   //              = 1 Tevatron 
   //              = 2 Profile Likelihood two sided
   //              = 3 Profile Likelihood one sided (i.e. = 0 if mu < mu_hat)
   //              = 4 Profile Likelihood signed ( pll = -pll if mu < mu_hat) 
   //              = 5 Max Likelihood Estimate as test statistic
   //              = 6 Number of observed event as test statistic
   //

   // 0,3,true for frequentist CLs; 2,3,true for asymptotic CLs; 0,2,false for FC
   int calculatorType = 0;
   int testStatType = 2;
   bool useCLs = false;
   // root> StandardHypoTestInvDemo("fileName","workspace name","S+B modelconfig name","B model name","data set name",calculator type, test statistic type, use CLS, 
   //                                number of points, xmin, xmax, number of toys, use number counting)
   // pair<double,double> lims_data = StandardHypoTestInvDemo(f->GetName(),
   //       ws,
   //       sbHypo,
   //       bHypo,
   //       "data",                 
   //       calculatorType,
   //       testStatType, 
   //       useCLs,  
   //       20,   
   //       poimin,  
   //       poimax, 
   //       1000,
   //       false,
   //       0);
   pair<double,double> lims_data = TwoSidedFrequentistUpperLimitWithBands(f->GetName(),
         ws,
         sbHypo->GetName(),
         "data", false);
   cout << lims_data.first << " " << lims_data.second << endl;

   // let's try on pseudo-data
   
   const int npoints = 10; 
   double thepoimax = 0.2;
   double lowlim[npoints];
   double upplim[npoints];
   double lowlim_ls[npoints];
   double upplim_ls[npoints];
   double mu[npoints];
   double muhat[npoints];
   RooRealVar * var = ws->var("invariantMass");
   RooRealVar * var2 = ws->var("muPlusPt");
   RooCategory *dataCat = ws->cat("dataCat");
   // RooDataSet *protoData = (RooDataSet*)ws->data("data");
   
   for (int i=0; i<npoints; i++)
   {
      // firstPOI->setMin(-1);
      mu[i] = i*(thepoimax/npoints);
      firstPOI->setVal(mu[i]);
      // RooRealVar *var = sbHypo->GetObservables()->first();;
      cout << var->GetName() << endl;
      RooDataSet * osSigData = 
         (RooDataSet *)ws->data("data")->emptyClone(Form("toy_os_Data_%f",mu[i]));
      RooDataSet * tmpData = sbHypo->GetPdf()->generate(RooArgSet(*var,*dataCat)
            // protoData->numEntries(),
            // RooFit::ProtoData(*protoData)
            );
      osSigData->append(*tmpData);
      delete tmpData;
      ws->import(*osSigData);
      osSigData->Print();

      RooAbsReal * pNll = sbHypo.GetPdf()->createNLL( *osSigData,NumCPU(2) );
      RooMinuit(*pNll).migrad(); // minimize likelihood wrt all parameters before making plots
      muhat[i] = firstPOI->getVal();

      cout << "---------------------------------------------------------------------------------------------------------------------------" << endl;
      RooStats::ProfileLikelihoodCalculator plc(*osSigData, *sbHypo);
      plc.SetTestSize(1.-CI);
      ConfInterval* plcInterval = plc.GetInterval();
      cout << "---------------------------------------------------------------------------------------------------------------------------" << endl;
      lowlim_ls[i] = ((LikelihoodInterval*) plcInterval)->LowerLimit(*firstPOI);
      upplim_ls[i] = ((LikelihoodInterval*) plcInterval)->UpperLimit(*firstPOI);

      // firstPOI->setMin(0);

      // RooPlot* xframeSB = var->frame(Title("SBhypo"));
      // osSigData->plotOn(xframeSB,Cut("dataCat==dataCat::hi"));
      // RooAbsPdf *pdfSB = sbHypo->GetPdf();
      // pdfSB->plotOn(xframeSB,Slice(*dataCat,"hi"),ProjWData(*dataCat,*osSigData));
      // xframeSB->Draw();

      // pair<double,double> lims2 = StandardHypoTestInvDemo(f->GetName(),
      //       ws,
      //       sbHypo,
      //       bHypo,
      //       Form("toy_os_Data_%f",mu[i]),
      //       calculatorType,
      //       testStatType, 
      //       useCLs,  
      //       20,   
      //       poimin,  
      //       poimax, 
      //       1000,
      //       false,
      //       0);
      pair<double,double> lims2 = TwoSidedFrequentistUpperLimitWithBands(f->GetName(),
            ws,
            sbHypo->GetName(),
            Form("toy_os_Data_%f",mu[i]), false);
      cout << lims2.first << " " << lims2.second << endl;
      lowlim[i] = lims2.first;
      upplim[i] = lims2.second;

      delete osSigData;
   }

   // stupid sort of the result arrays
   for (int i=0; i<npoints; i++)
      for (int j=i+1; j<npoints; j++)
         if (muhat[i]>muhat[j])
      {
         double muhbuf=muhat[i],lowbuf=lowlim[i],uppbuf=upplim[i],lowbuf_ls=lowlim_ls[i],uppbuf_ls=upplim_ls[i],mubuf=mu[i];
         muhat[i]=muhat[j];lowlim[i]=lowlim[j];upplim[i]=upplim[j];lowlim_ls[i]=lowlim_ls[j];upplim_ls[i]=upplim_ls[j];mu[i]=mu[j];
         muhat[j]=muhbuf;lowlim[j]=lowbuf;upplim[j]=uppbuf;lowlim_ls[j]=lowbuf_ls;upplim_ls[j]=uppbuf_ls;mu[j]=mubuf;
      }

   for (int i=0; i<npoints; i++)
      cout << muhat[i] << " " << lowlim[i] << " " << upplim[i] << ", LS -> " << lowlim_ls[i] << " " << upplim_ls[i] << endl;

   cout << "data " << muhat_data << " " << lims_data.first << " " << lims_data.second << endl;

   // TGraph *gupp = new TGraph(npoints,muhat,upplim);
   // TGraph *glow = new TGraph(npoints,muhat,lowlim);
   // TGraph *gmu = new TGraph(npoints,muhat,mu);
   double eyl[npoints]; double eyh[npoints];
   double eyl_ls[npoints]; double eyh_ls[npoints];
   for (int i=0; i<npoints; i++)
   {
      eyl[i] = mu[i]-lowlim[i];
      eyh[i] = upplim[i]-mu[i];
      eyl_ls[i] = mu[i]-lowlim_ls[i];
      eyh_ls[i] = upplim_ls[i]-mu[i];
   }
   TGraphAsymmErrors *tgmu = new TGraphAsymmErrors(npoints,muhat,mu,0,0,eyl,eyh);
   TGraphAsymmErrors *tgmu_ls = new TGraphAsymmErrors(npoints,muhat,mu,0,0,eyl_ls,eyh_ls);
   TGraph *tgmune = new TGraph(npoints,muhat,mu);
   TLine *limdata = new TLine(muhat_data,lims_data.first,muhat_data,lims_data.second);
   TH1F *haxes = new TH1F("haxes","FC",1,-0.1,0.5);

   TCanvas *c2 = new TCanvas();c2->cd();

   haxes->GetYaxis()->SetRangeUser(0,0.5);
   haxes->Draw();
   tgmune->Draw("l");
   tgmu->SetFillColor(6);
   tgmu->SetFillStyle(3005);
   tgmu->Draw("3");
   tgmu_ls->SetFillColor(4);
   tgmu_ls->SetFillStyle(3004);
   tgmu_ls->Draw("3");
   // gupp->Draw("l");
   // glow->Draw("l");
   limdata->Draw();

   c2->SaveAs("limitscan_twosidedfreq.pdf");
   c2->SaveAs("limitscan_twosidedfreq.C");
}
